//
// Autogenerated by Thrift Compiler (0.7.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
var Thrift = require('thrift').Thrift;

var ttypes = require('./cassandra_types');
//HELPER FUNCTIONS AND STRUCTURES

var Cassandra_login_args = function(args) {
  this.auth_request = null;
  if (args) {
    if (args.auth_request !== undefined) {
      this.auth_request = args.auth_request;
    }
  }
};
Cassandra_login_args.prototype = {};
Cassandra_login_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.auth_request = new ttypes.AuthenticationRequest();
        this.auth_request.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_login_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_login_args');
  if (this.auth_request != null) {
    output.writeFieldBegin('auth_request', Thrift.Type.STRUCT, 1);
    this.auth_request.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_login_result = function(args) {
  this.authnx = null;
  this.authzx = null;
  if (args) {
    if (args.authnx !== undefined) {
      this.authnx = args.authnx;
    }
    if (args.authzx !== undefined) {
      this.authzx = args.authzx;
    }
  }
};
Cassandra_login_result.prototype = {};
Cassandra_login_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.authnx = new ttypes.AuthenticationException();
        this.authnx.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.authzx = new ttypes.AuthorizationException();
        this.authzx.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_login_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_login_result');
  if (this.authnx != null) {
    output.writeFieldBegin('authnx', Thrift.Type.STRUCT, 1);
    this.authnx.write(output);
    output.writeFieldEnd();
  }
  if (this.authzx != null) {
    output.writeFieldBegin('authzx', Thrift.Type.STRUCT, 2);
    this.authzx.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_set_keyspace_args = function(args) {
  this.keyspace = null;
  if (args) {
    if (args.keyspace !== undefined) {
      this.keyspace = args.keyspace;
    }
  }
};
Cassandra_set_keyspace_args.prototype = {};
Cassandra_set_keyspace_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.keyspace = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_set_keyspace_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_set_keyspace_args');
  if (this.keyspace != null) {
    output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1);
    output.writeString(this.keyspace);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_set_keyspace_result = function(args) {
  this.ire = null;
  if (args) {
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
  }
};
Cassandra_set_keyspace_result.prototype = {};
Cassandra_set_keyspace_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_set_keyspace_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_set_keyspace_result');
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_get_args = function(args) {
  this.key = null;
  this.column_path = null;
  this.consistency_level = 1;
  if (args) {
    if (args.key !== undefined) {
      this.key = args.key;
    }
    if (args.column_path !== undefined) {
      this.column_path = args.column_path;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_get_args.prototype = {};
Cassandra_get_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.key = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.column_path = new ttypes.ColumnPath();
        this.column_path.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_get_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_get_args');
  if (this.key != null) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1);
    output.writeString(this.key);
    output.writeFieldEnd();
  }
  if (this.column_path != null) {
    output.writeFieldBegin('column_path', Thrift.Type.STRUCT, 2);
    this.column_path.write(output);
    output.writeFieldEnd();
  }
  if (this.consistency_level != null) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 3);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_get_result = function(args) {
  this.success = null;
  this.ire = null;
  this.nfe = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.nfe !== undefined) {
      this.nfe = args.nfe;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_get_result.prototype = {};
Cassandra_get_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRUCT) {
        this.success = new ttypes.ColumnOrSuperColumn();
        this.success.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.nfe = new ttypes.NotFoundException();
        this.nfe.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_get_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_get_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
    this.success.write(output);
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.nfe != null) {
    output.writeFieldBegin('nfe', Thrift.Type.STRUCT, 2);
    this.nfe.write(output);
    output.writeFieldEnd();
  }
  if (this.ue != null) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 3);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te != null) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 4);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_get_slice_args = function(args) {
  this.key = null;
  this.column_parent = null;
  this.predicate = null;
  this.consistency_level = 1;
  if (args) {
    if (args.key !== undefined) {
      this.key = args.key;
    }
    if (args.column_parent !== undefined) {
      this.column_parent = args.column_parent;
    }
    if (args.predicate !== undefined) {
      this.predicate = args.predicate;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_get_slice_args.prototype = {};
Cassandra_get_slice_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.key = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent();
        this.column_parent.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.predicate = new ttypes.SlicePredicate();
        this.predicate.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_get_slice_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_get_slice_args');
  if (this.key != null) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1);
    output.writeString(this.key);
    output.writeFieldEnd();
  }
  if (this.column_parent != null) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2);
    this.column_parent.write(output);
    output.writeFieldEnd();
  }
  if (this.predicate != null) {
    output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 3);
    this.predicate.write(output);
    output.writeFieldEnd();
  }
  if (this.consistency_level != null) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_get_slice_result = function(args) {
  this.success = null;
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_get_slice_result.prototype = {};
Cassandra_get_slice_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.LIST) {
        var _size166 = 0;
        var _rtmp3170;
        this.success = [];
        var _etype169 = 0;
        _rtmp3170 = input.readListBegin();
        _etype169 = _rtmp3170.etype;
        _size166 = _rtmp3170.size;
        for (var _i171 = 0; _i171 < _size166; ++_i171)
        {
          var elem172 = null;
          elem172 = new ttypes.ColumnOrSuperColumn();
          elem172.read(input);
          this.success.push(elem172);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_get_slice_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_get_slice_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0);
    output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
    for (var iter173 in this.success)
    {
      if (this.success.hasOwnProperty(iter173))
      {
        iter173 = this.success[iter173];
        iter173.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue != null) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te != null) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_get_count_args = function(args) {
  this.key = null;
  this.column_parent = null;
  this.predicate = null;
  this.consistency_level = 1;
  if (args) {
    if (args.key !== undefined) {
      this.key = args.key;
    }
    if (args.column_parent !== undefined) {
      this.column_parent = args.column_parent;
    }
    if (args.predicate !== undefined) {
      this.predicate = args.predicate;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_get_count_args.prototype = {};
Cassandra_get_count_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.key = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent();
        this.column_parent.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.predicate = new ttypes.SlicePredicate();
        this.predicate.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_get_count_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_get_count_args');
  if (this.key != null) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1);
    output.writeString(this.key);
    output.writeFieldEnd();
  }
  if (this.column_parent != null) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2);
    this.column_parent.write(output);
    output.writeFieldEnd();
  }
  if (this.predicate != null) {
    output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 3);
    this.predicate.write(output);
    output.writeFieldEnd();
  }
  if (this.consistency_level != null) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_get_count_result = function(args) {
  this.success = null;
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_get_count_result.prototype = {};
Cassandra_get_count_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.I32) {
        this.success = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_get_count_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_get_count_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.I32, 0);
    output.writeI32(this.success);
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue != null) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te != null) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_multiget_slice_args = function(args) {
  this.keys = null;
  this.column_parent = null;
  this.predicate = null;
  this.consistency_level = 1;
  if (args) {
    if (args.keys !== undefined) {
      this.keys = args.keys;
    }
    if (args.column_parent !== undefined) {
      this.column_parent = args.column_parent;
    }
    if (args.predicate !== undefined) {
      this.predicate = args.predicate;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_multiget_slice_args.prototype = {};
Cassandra_multiget_slice_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        var _size174 = 0;
        var _rtmp3178;
        this.keys = [];
        var _etype177 = 0;
        _rtmp3178 = input.readListBegin();
        _etype177 = _rtmp3178.etype;
        _size174 = _rtmp3178.size;
        for (var _i179 = 0; _i179 < _size174; ++_i179)
        {
          var elem180 = null;
          elem180 = input.readBinary();
          this.keys.push(elem180);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent();
        this.column_parent.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.predicate = new ttypes.SlicePredicate();
        this.predicate.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_multiget_slice_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_multiget_slice_args');
  if (this.keys != null) {
    output.writeFieldBegin('keys', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRING, this.keys.length);
    for (var iter181 in this.keys)
    {
      if (this.keys.hasOwnProperty(iter181))
      {
        iter181 = this.keys[iter181];
        output.writeString(iter181);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.column_parent != null) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2);
    this.column_parent.write(output);
    output.writeFieldEnd();
  }
  if (this.predicate != null) {
    output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 3);
    this.predicate.write(output);
    output.writeFieldEnd();
  }
  if (this.consistency_level != null) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_multiget_slice_result = function(args) {
  this.success = null;
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_multiget_slice_result.prototype = {};
Cassandra_multiget_slice_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.MAP) {
        var _size182 = 0;
        var _rtmp3186;
        this.success = {};
        var _ktype183 = 0;
        var _vtype184 = 0;
        _rtmp3186 = input.readMapBegin();
        _ktype183 = _rtmp3186.ktype;
        _vtype184 = _rtmp3186.vtype;
        _size182 = _rtmp3186.size;
        for (var _i187 = 0; _i187 < _size182; ++_i187)
        {
          var key188 = null;
          var val189 = null;
          key188 = input.readBinary();
          var _size190 = 0;
          var _rtmp3194;
          val189 = [];
          var _etype193 = 0;
          _rtmp3194 = input.readListBegin();
          _etype193 = _rtmp3194.etype;
          _size190 = _rtmp3194.size;
          for (var _i195 = 0; _i195 < _size190; ++_i195)
          {
            var elem196 = null;
            elem196 = new ttypes.ColumnOrSuperColumn();
            elem196.read(input);
            val189.push(elem196);
          }
          input.readListEnd();
          this.success[key188] = val189;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_multiget_slice_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_multiget_slice_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.MAP, 0);
    output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.LIST, Thrift.objectLength(this.success));
    for (var kiter197 in this.success)
    {
      if (this.success.hasOwnProperty(kiter197))
      {
        var viter198 = this.success[kiter197];
        output.writeString(kiter197);
        output.writeListBegin(Thrift.Type.STRUCT, viter198.length);
        for (var iter199 in viter198)
        {
          if (viter198.hasOwnProperty(iter199))
          {
            iter199 = viter198[iter199];
            iter199.write(output);
          }
        }
        output.writeListEnd();
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue != null) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te != null) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_multiget_count_args = function(args) {
  this.keys = null;
  this.column_parent = null;
  this.predicate = null;
  this.consistency_level = 1;
  if (args) {
    if (args.keys !== undefined) {
      this.keys = args.keys;
    }
    if (args.column_parent !== undefined) {
      this.column_parent = args.column_parent;
    }
    if (args.predicate !== undefined) {
      this.predicate = args.predicate;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_multiget_count_args.prototype = {};
Cassandra_multiget_count_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        var _size200 = 0;
        var _rtmp3204;
        this.keys = [];
        var _etype203 = 0;
        _rtmp3204 = input.readListBegin();
        _etype203 = _rtmp3204.etype;
        _size200 = _rtmp3204.size;
        for (var _i205 = 0; _i205 < _size200; ++_i205)
        {
          var elem206 = null;
          elem206 = input.readBinary();
          this.keys.push(elem206);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent();
        this.column_parent.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.predicate = new ttypes.SlicePredicate();
        this.predicate.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_multiget_count_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_multiget_count_args');
  if (this.keys != null) {
    output.writeFieldBegin('keys', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRING, this.keys.length);
    for (var iter207 in this.keys)
    {
      if (this.keys.hasOwnProperty(iter207))
      {
        iter207 = this.keys[iter207];
        output.writeString(iter207);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.column_parent != null) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2);
    this.column_parent.write(output);
    output.writeFieldEnd();
  }
  if (this.predicate != null) {
    output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 3);
    this.predicate.write(output);
    output.writeFieldEnd();
  }
  if (this.consistency_level != null) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_multiget_count_result = function(args) {
  this.success = null;
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_multiget_count_result.prototype = {};
Cassandra_multiget_count_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.MAP) {
        var _size208 = 0;
        var _rtmp3212;
        this.success = {};
        var _ktype209 = 0;
        var _vtype210 = 0;
        _rtmp3212 = input.readMapBegin();
        _ktype209 = _rtmp3212.ktype;
        _vtype210 = _rtmp3212.vtype;
        _size208 = _rtmp3212.size;
        for (var _i213 = 0; _i213 < _size208; ++_i213)
        {
          var key214 = null;
          var val215 = null;
          key214 = input.readBinary();
          val215 = input.readI32();
          this.success[key214] = val215;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_multiget_count_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_multiget_count_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.MAP, 0);
    output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.I32, Thrift.objectLength(this.success));
    for (var kiter216 in this.success)
    {
      if (this.success.hasOwnProperty(kiter216))
      {
        var viter217 = this.success[kiter216];
        output.writeString(kiter216);
        output.writeI32(viter217);
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue != null) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te != null) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_get_range_slices_args = function(args) {
  this.column_parent = null;
  this.predicate = null;
  this.range = null;
  this.consistency_level = 1;
  if (args) {
    if (args.column_parent !== undefined) {
      this.column_parent = args.column_parent;
    }
    if (args.predicate !== undefined) {
      this.predicate = args.predicate;
    }
    if (args.range !== undefined) {
      this.range = args.range;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_get_range_slices_args.prototype = {};
Cassandra_get_range_slices_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent();
        this.column_parent.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.predicate = new ttypes.SlicePredicate();
        this.predicate.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.range = new ttypes.KeyRange();
        this.range.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_get_range_slices_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_get_range_slices_args');
  if (this.column_parent != null) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 1);
    this.column_parent.write(output);
    output.writeFieldEnd();
  }
  if (this.predicate != null) {
    output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 2);
    this.predicate.write(output);
    output.writeFieldEnd();
  }
  if (this.range != null) {
    output.writeFieldBegin('range', Thrift.Type.STRUCT, 3);
    this.range.write(output);
    output.writeFieldEnd();
  }
  if (this.consistency_level != null) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_get_range_slices_result = function(args) {
  this.success = null;
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_get_range_slices_result.prototype = {};
Cassandra_get_range_slices_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.LIST) {
        var _size218 = 0;
        var _rtmp3222;
        this.success = [];
        var _etype221 = 0;
        _rtmp3222 = input.readListBegin();
        _etype221 = _rtmp3222.etype;
        _size218 = _rtmp3222.size;
        for (var _i223 = 0; _i223 < _size218; ++_i223)
        {
          var elem224 = null;
          elem224 = new ttypes.KeySlice();
          elem224.read(input);
          this.success.push(elem224);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_get_range_slices_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_get_range_slices_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0);
    output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
    for (var iter225 in this.success)
    {
      if (this.success.hasOwnProperty(iter225))
      {
        iter225 = this.success[iter225];
        iter225.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue != null) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te != null) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_get_indexed_slices_args = function(args) {
  this.column_parent = null;
  this.index_clause = null;
  this.column_predicate = null;
  this.consistency_level = 1;
  if (args) {
    if (args.column_parent !== undefined) {
      this.column_parent = args.column_parent;
    }
    if (args.index_clause !== undefined) {
      this.index_clause = args.index_clause;
    }
    if (args.column_predicate !== undefined) {
      this.column_predicate = args.column_predicate;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_get_indexed_slices_args.prototype = {};
Cassandra_get_indexed_slices_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent();
        this.column_parent.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.index_clause = new ttypes.IndexClause();
        this.index_clause.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.column_predicate = new ttypes.SlicePredicate();
        this.column_predicate.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_get_indexed_slices_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_get_indexed_slices_args');
  if (this.column_parent != null) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 1);
    this.column_parent.write(output);
    output.writeFieldEnd();
  }
  if (this.index_clause != null) {
    output.writeFieldBegin('index_clause', Thrift.Type.STRUCT, 2);
    this.index_clause.write(output);
    output.writeFieldEnd();
  }
  if (this.column_predicate != null) {
    output.writeFieldBegin('column_predicate', Thrift.Type.STRUCT, 3);
    this.column_predicate.write(output);
    output.writeFieldEnd();
  }
  if (this.consistency_level != null) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_get_indexed_slices_result = function(args) {
  this.success = null;
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_get_indexed_slices_result.prototype = {};
Cassandra_get_indexed_slices_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.LIST) {
        var _size226 = 0;
        var _rtmp3230;
        this.success = [];
        var _etype229 = 0;
        _rtmp3230 = input.readListBegin();
        _etype229 = _rtmp3230.etype;
        _size226 = _rtmp3230.size;
        for (var _i231 = 0; _i231 < _size226; ++_i231)
        {
          var elem232 = null;
          elem232 = new ttypes.KeySlice();
          elem232.read(input);
          this.success.push(elem232);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_get_indexed_slices_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_get_indexed_slices_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0);
    output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
    for (var iter233 in this.success)
    {
      if (this.success.hasOwnProperty(iter233))
      {
        iter233 = this.success[iter233];
        iter233.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue != null) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te != null) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_insert_args = function(args) {
  this.key = null;
  this.column_parent = null;
  this.column = null;
  this.consistency_level = 1;
  if (args) {
    if (args.key !== undefined) {
      this.key = args.key;
    }
    if (args.column_parent !== undefined) {
      this.column_parent = args.column_parent;
    }
    if (args.column !== undefined) {
      this.column = args.column;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_insert_args.prototype = {};
Cassandra_insert_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.key = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent();
        this.column_parent.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.column = new ttypes.Column();
        this.column.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_insert_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_insert_args');
  if (this.key != null) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1);
    output.writeString(this.key);
    output.writeFieldEnd();
  }
  if (this.column_parent != null) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2);
    this.column_parent.write(output);
    output.writeFieldEnd();
  }
  if (this.column != null) {
    output.writeFieldBegin('column', Thrift.Type.STRUCT, 3);
    this.column.write(output);
    output.writeFieldEnd();
  }
  if (this.consistency_level != null) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_insert_result = function(args) {
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_insert_result.prototype = {};
Cassandra_insert_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_insert_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_insert_result');
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue != null) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te != null) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_add_args = function(args) {
  this.key = null;
  this.column_parent = null;
  this.column = null;
  this.consistency_level = 1;
  if (args) {
    if (args.key !== undefined) {
      this.key = args.key;
    }
    if (args.column_parent !== undefined) {
      this.column_parent = args.column_parent;
    }
    if (args.column !== undefined) {
      this.column = args.column;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_add_args.prototype = {};
Cassandra_add_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.key = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent();
        this.column_parent.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.column = new ttypes.CounterColumn();
        this.column.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_add_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_add_args');
  if (this.key != null) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1);
    output.writeString(this.key);
    output.writeFieldEnd();
  }
  if (this.column_parent != null) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2);
    this.column_parent.write(output);
    output.writeFieldEnd();
  }
  if (this.column != null) {
    output.writeFieldBegin('column', Thrift.Type.STRUCT, 3);
    this.column.write(output);
    output.writeFieldEnd();
  }
  if (this.consistency_level != null) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_add_result = function(args) {
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_add_result.prototype = {};
Cassandra_add_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_add_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_add_result');
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue != null) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te != null) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_remove_args = function(args) {
  this.key = null;
  this.column_path = null;
  this.timestamp = null;
  this.consistency_level = 1;
  if (args) {
    if (args.key !== undefined) {
      this.key = args.key;
    }
    if (args.column_path !== undefined) {
      this.column_path = args.column_path;
    }
    if (args.timestamp !== undefined) {
      this.timestamp = args.timestamp;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_remove_args.prototype = {};
Cassandra_remove_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.key = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.column_path = new ttypes.ColumnPath();
        this.column_path.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I64) {
        this.timestamp = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_remove_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_remove_args');
  if (this.key != null) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1);
    output.writeString(this.key);
    output.writeFieldEnd();
  }
  if (this.column_path != null) {
    output.writeFieldBegin('column_path', Thrift.Type.STRUCT, 2);
    this.column_path.write(output);
    output.writeFieldEnd();
  }
  if (this.timestamp != null) {
    output.writeFieldBegin('timestamp', Thrift.Type.I64, 3);
    output.writeI64(this.timestamp);
    output.writeFieldEnd();
  }
  if (this.consistency_level != null) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_remove_result = function(args) {
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_remove_result.prototype = {};
Cassandra_remove_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_remove_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_remove_result');
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue != null) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te != null) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_remove_counter_args = function(args) {
  this.key = null;
  this.path = null;
  this.consistency_level = 1;
  if (args) {
    if (args.key !== undefined) {
      this.key = args.key;
    }
    if (args.path !== undefined) {
      this.path = args.path;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_remove_counter_args.prototype = {};
Cassandra_remove_counter_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.key = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.path = new ttypes.ColumnPath();
        this.path.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_remove_counter_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_remove_counter_args');
  if (this.key != null) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1);
    output.writeString(this.key);
    output.writeFieldEnd();
  }
  if (this.path != null) {
    output.writeFieldBegin('path', Thrift.Type.STRUCT, 2);
    this.path.write(output);
    output.writeFieldEnd();
  }
  if (this.consistency_level != null) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 3);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_remove_counter_result = function(args) {
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_remove_counter_result.prototype = {};
Cassandra_remove_counter_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_remove_counter_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_remove_counter_result');
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue != null) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te != null) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_batch_mutate_args = function(args) {
  this.mutation_map = null;
  this.consistency_level = 1;
  if (args) {
    if (args.mutation_map !== undefined) {
      this.mutation_map = args.mutation_map;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_batch_mutate_args.prototype = {};
Cassandra_batch_mutate_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.MAP) {
        var _size234 = 0;
        var _rtmp3238;
        this.mutation_map = {};
        var _ktype235 = 0;
        var _vtype236 = 0;
        _rtmp3238 = input.readMapBegin();
        _ktype235 = _rtmp3238.ktype;
        _vtype236 = _rtmp3238.vtype;
        _size234 = _rtmp3238.size;
        for (var _i239 = 0; _i239 < _size234; ++_i239)
        {
          var key240 = null;
          var val241 = null;
          key240 = input.readBinary();
          var _size242 = 0;
          var _rtmp3246;
          val241 = {};
          var _ktype243 = 0;
          var _vtype244 = 0;
          _rtmp3246 = input.readMapBegin();
          _ktype243 = _rtmp3246.ktype;
          _vtype244 = _rtmp3246.vtype;
          _size242 = _rtmp3246.size;
          for (var _i247 = 0; _i247 < _size242; ++_i247)
          {
            var key248 = null;
            var val249 = null;
            key248 = input.readString();
            var _size250 = 0;
            var _rtmp3254;
            val249 = [];
            var _etype253 = 0;
            _rtmp3254 = input.readListBegin();
            _etype253 = _rtmp3254.etype;
            _size250 = _rtmp3254.size;
            for (var _i255 = 0; _i255 < _size250; ++_i255)
            {
              var elem256 = null;
              elem256 = new ttypes.Mutation();
              elem256.read(input);
              val249.push(elem256);
            }
            input.readListEnd();
            val241[key248] = val249;
          }
          input.readMapEnd();
          this.mutation_map[key240] = val241;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_batch_mutate_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_batch_mutate_args');
  if (this.mutation_map != null) {
    output.writeFieldBegin('mutation_map', Thrift.Type.MAP, 1);
    output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.MAP, Thrift.objectLength(this.mutation_map));
    for (var kiter257 in this.mutation_map)
    {
      if (this.mutation_map.hasOwnProperty(kiter257))
      {
        var viter258 = this.mutation_map[kiter257];
        output.writeString(kiter257);
        output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.LIST, Thrift.objectLength(viter258));
        for (var kiter259 in viter258)
        {
          if (viter258.hasOwnProperty(kiter259))
          {
            var viter260 = viter258[kiter259];
            output.writeString(kiter259);
            output.writeListBegin(Thrift.Type.STRUCT, viter260.length);
            for (var iter261 in viter260)
            {
              if (viter260.hasOwnProperty(iter261))
              {
                iter261 = viter260[iter261];
                iter261.write(output);
              }
            }
            output.writeListEnd();
          }
        }
        output.writeMapEnd();
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  if (this.consistency_level != null) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 2);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_batch_mutate_result = function(args) {
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_batch_mutate_result.prototype = {};
Cassandra_batch_mutate_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_batch_mutate_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_batch_mutate_result');
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue != null) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te != null) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_truncate_args = function(args) {
  this.cfname = null;
  if (args) {
    if (args.cfname !== undefined) {
      this.cfname = args.cfname;
    }
  }
};
Cassandra_truncate_args.prototype = {};
Cassandra_truncate_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.cfname = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_truncate_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_truncate_args');
  if (this.cfname != null) {
    output.writeFieldBegin('cfname', Thrift.Type.STRING, 1);
    output.writeString(this.cfname);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_truncate_result = function(args) {
  this.ire = null;
  this.ue = null;
  if (args) {
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
  }
};
Cassandra_truncate_result.prototype = {};
Cassandra_truncate_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_truncate_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_truncate_result');
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue != null) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_schema_versions_args = function(args) {
};
Cassandra_describe_schema_versions_args.prototype = {};
Cassandra_describe_schema_versions_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_schema_versions_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_schema_versions_args');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_schema_versions_result = function(args) {
  this.success = null;
  this.ire = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
  }
};
Cassandra_describe_schema_versions_result.prototype = {};
Cassandra_describe_schema_versions_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.MAP) {
        var _size262 = 0;
        var _rtmp3266;
        this.success = {};
        var _ktype263 = 0;
        var _vtype264 = 0;
        _rtmp3266 = input.readMapBegin();
        _ktype263 = _rtmp3266.ktype;
        _vtype264 = _rtmp3266.vtype;
        _size262 = _rtmp3266.size;
        for (var _i267 = 0; _i267 < _size262; ++_i267)
        {
          var key268 = null;
          var val269 = null;
          key268 = input.readString();
          var _size270 = 0;
          var _rtmp3274;
          val269 = [];
          var _etype273 = 0;
          _rtmp3274 = input.readListBegin();
          _etype273 = _rtmp3274.etype;
          _size270 = _rtmp3274.size;
          for (var _i275 = 0; _i275 < _size270; ++_i275)
          {
            var elem276 = null;
            elem276 = input.readString();
            val269.push(elem276);
          }
          input.readListEnd();
          this.success[key268] = val269;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_schema_versions_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_schema_versions_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.MAP, 0);
    output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.LIST, Thrift.objectLength(this.success));
    for (var kiter277 in this.success)
    {
      if (this.success.hasOwnProperty(kiter277))
      {
        var viter278 = this.success[kiter277];
        output.writeString(kiter277);
        output.writeListBegin(Thrift.Type.STRING, viter278.length);
        for (var iter279 in viter278)
        {
          if (viter278.hasOwnProperty(iter279))
          {
            iter279 = viter278[iter279];
            output.writeString(iter279);
          }
        }
        output.writeListEnd();
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_keyspaces_args = function(args) {
};
Cassandra_describe_keyspaces_args.prototype = {};
Cassandra_describe_keyspaces_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_keyspaces_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_keyspaces_args');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_keyspaces_result = function(args) {
  this.success = null;
  this.ire = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
  }
};
Cassandra_describe_keyspaces_result.prototype = {};
Cassandra_describe_keyspaces_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.LIST) {
        var _size280 = 0;
        var _rtmp3284;
        this.success = [];
        var _etype283 = 0;
        _rtmp3284 = input.readListBegin();
        _etype283 = _rtmp3284.etype;
        _size280 = _rtmp3284.size;
        for (var _i285 = 0; _i285 < _size280; ++_i285)
        {
          var elem286 = null;
          elem286 = new ttypes.KsDef();
          elem286.read(input);
          this.success.push(elem286);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_keyspaces_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_keyspaces_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0);
    output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
    for (var iter287 in this.success)
    {
      if (this.success.hasOwnProperty(iter287))
      {
        iter287 = this.success[iter287];
        iter287.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_cluster_name_args = function(args) {
};
Cassandra_describe_cluster_name_args.prototype = {};
Cassandra_describe_cluster_name_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_cluster_name_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_cluster_name_args');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_cluster_name_result = function(args) {
  this.success = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
  }
};
Cassandra_describe_cluster_name_result.prototype = {};
Cassandra_describe_cluster_name_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_cluster_name_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_cluster_name_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0);
    output.writeString(this.success);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_version_args = function(args) {
};
Cassandra_describe_version_args.prototype = {};
Cassandra_describe_version_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_version_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_version_args');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_version_result = function(args) {
  this.success = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
  }
};
Cassandra_describe_version_result.prototype = {};
Cassandra_describe_version_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_version_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_version_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0);
    output.writeString(this.success);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_ring_args = function(args) {
  this.keyspace = null;
  if (args) {
    if (args.keyspace !== undefined) {
      this.keyspace = args.keyspace;
    }
  }
};
Cassandra_describe_ring_args.prototype = {};
Cassandra_describe_ring_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.keyspace = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_ring_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_ring_args');
  if (this.keyspace != null) {
    output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1);
    output.writeString(this.keyspace);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_ring_result = function(args) {
  this.success = null;
  this.ire = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
  }
};
Cassandra_describe_ring_result.prototype = {};
Cassandra_describe_ring_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.LIST) {
        var _size288 = 0;
        var _rtmp3292;
        this.success = [];
        var _etype291 = 0;
        _rtmp3292 = input.readListBegin();
        _etype291 = _rtmp3292.etype;
        _size288 = _rtmp3292.size;
        for (var _i293 = 0; _i293 < _size288; ++_i293)
        {
          var elem294 = null;
          elem294 = new ttypes.TokenRange();
          elem294.read(input);
          this.success.push(elem294);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_ring_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_ring_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0);
    output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
    for (var iter295 in this.success)
    {
      if (this.success.hasOwnProperty(iter295))
      {
        iter295 = this.success[iter295];
        iter295.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_partitioner_args = function(args) {
};
Cassandra_describe_partitioner_args.prototype = {};
Cassandra_describe_partitioner_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_partitioner_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_partitioner_args');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_partitioner_result = function(args) {
  this.success = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
  }
};
Cassandra_describe_partitioner_result.prototype = {};
Cassandra_describe_partitioner_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_partitioner_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_partitioner_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0);
    output.writeString(this.success);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_snitch_args = function(args) {
};
Cassandra_describe_snitch_args.prototype = {};
Cassandra_describe_snitch_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_snitch_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_snitch_args');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_snitch_result = function(args) {
  this.success = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
  }
};
Cassandra_describe_snitch_result.prototype = {};
Cassandra_describe_snitch_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_snitch_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_snitch_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0);
    output.writeString(this.success);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_keyspace_args = function(args) {
  this.keyspace = null;
  if (args) {
    if (args.keyspace !== undefined) {
      this.keyspace = args.keyspace;
    }
  }
};
Cassandra_describe_keyspace_args.prototype = {};
Cassandra_describe_keyspace_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.keyspace = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_keyspace_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_keyspace_args');
  if (this.keyspace != null) {
    output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1);
    output.writeString(this.keyspace);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_keyspace_result = function(args) {
  this.success = null;
  this.nfe = null;
  this.ire = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.nfe !== undefined) {
      this.nfe = args.nfe;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
  }
};
Cassandra_describe_keyspace_result.prototype = {};
Cassandra_describe_keyspace_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRUCT) {
        this.success = new ttypes.KsDef();
        this.success.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.nfe = new ttypes.NotFoundException();
        this.nfe.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_keyspace_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_keyspace_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
    this.success.write(output);
    output.writeFieldEnd();
  }
  if (this.nfe != null) {
    output.writeFieldBegin('nfe', Thrift.Type.STRUCT, 1);
    this.nfe.write(output);
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 2);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_splits_args = function(args) {
  this.cfName = null;
  this.start_token = null;
  this.end_token = null;
  this.keys_per_split = null;
  if (args) {
    if (args.cfName !== undefined) {
      this.cfName = args.cfName;
    }
    if (args.start_token !== undefined) {
      this.start_token = args.start_token;
    }
    if (args.end_token !== undefined) {
      this.end_token = args.end_token;
    }
    if (args.keys_per_split !== undefined) {
      this.keys_per_split = args.keys_per_split;
    }
  }
};
Cassandra_describe_splits_args.prototype = {};
Cassandra_describe_splits_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.cfName = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.start_token = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.end_token = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.keys_per_split = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_splits_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_splits_args');
  if (this.cfName != null) {
    output.writeFieldBegin('cfName', Thrift.Type.STRING, 1);
    output.writeString(this.cfName);
    output.writeFieldEnd();
  }
  if (this.start_token != null) {
    output.writeFieldBegin('start_token', Thrift.Type.STRING, 2);
    output.writeString(this.start_token);
    output.writeFieldEnd();
  }
  if (this.end_token != null) {
    output.writeFieldBegin('end_token', Thrift.Type.STRING, 3);
    output.writeString(this.end_token);
    output.writeFieldEnd();
  }
  if (this.keys_per_split != null) {
    output.writeFieldBegin('keys_per_split', Thrift.Type.I32, 4);
    output.writeI32(this.keys_per_split);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_splits_result = function(args) {
  this.success = null;
  this.ire = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
  }
};
Cassandra_describe_splits_result.prototype = {};
Cassandra_describe_splits_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.LIST) {
        var _size296 = 0;
        var _rtmp3300;
        this.success = [];
        var _etype299 = 0;
        _rtmp3300 = input.readListBegin();
        _etype299 = _rtmp3300.etype;
        _size296 = _rtmp3300.size;
        for (var _i301 = 0; _i301 < _size296; ++_i301)
        {
          var elem302 = null;
          elem302 = input.readString();
          this.success.push(elem302);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_splits_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_splits_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0);
    output.writeListBegin(Thrift.Type.STRING, this.success.length);
    for (var iter303 in this.success)
    {
      if (this.success.hasOwnProperty(iter303))
      {
        iter303 = this.success[iter303];
        output.writeString(iter303);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_add_column_family_args = function(args) {
  this.cf_def = null;
  if (args) {
    if (args.cf_def !== undefined) {
      this.cf_def = args.cf_def;
    }
  }
};
Cassandra_system_add_column_family_args.prototype = {};
Cassandra_system_add_column_family_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.cf_def = new ttypes.CfDef();
        this.cf_def.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_add_column_family_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_add_column_family_args');
  if (this.cf_def != null) {
    output.writeFieldBegin('cf_def', Thrift.Type.STRUCT, 1);
    this.cf_def.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_add_column_family_result = function(args) {
  this.success = null;
  this.ire = null;
  this.sde = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.sde !== undefined) {
      this.sde = args.sde;
    }
  }
};
Cassandra_system_add_column_family_result.prototype = {};
Cassandra_system_add_column_family_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException();
        this.sde.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_add_column_family_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_add_column_family_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0);
    output.writeString(this.success);
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.sde != null) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 2);
    this.sde.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_drop_column_family_args = function(args) {
  this.column_family = null;
  if (args) {
    if (args.column_family !== undefined) {
      this.column_family = args.column_family;
    }
  }
};
Cassandra_system_drop_column_family_args.prototype = {};
Cassandra_system_drop_column_family_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.column_family = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_drop_column_family_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_drop_column_family_args');
  if (this.column_family != null) {
    output.writeFieldBegin('column_family', Thrift.Type.STRING, 1);
    output.writeString(this.column_family);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_drop_column_family_result = function(args) {
  this.success = null;
  this.ire = null;
  this.sde = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.sde !== undefined) {
      this.sde = args.sde;
    }
  }
};
Cassandra_system_drop_column_family_result.prototype = {};
Cassandra_system_drop_column_family_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException();
        this.sde.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_drop_column_family_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_drop_column_family_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0);
    output.writeString(this.success);
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.sde != null) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 2);
    this.sde.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_add_keyspace_args = function(args) {
  this.ks_def = null;
  if (args) {
    if (args.ks_def !== undefined) {
      this.ks_def = args.ks_def;
    }
  }
};
Cassandra_system_add_keyspace_args.prototype = {};
Cassandra_system_add_keyspace_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ks_def = new ttypes.KsDef();
        this.ks_def.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_add_keyspace_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_add_keyspace_args');
  if (this.ks_def != null) {
    output.writeFieldBegin('ks_def', Thrift.Type.STRUCT, 1);
    this.ks_def.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_add_keyspace_result = function(args) {
  this.success = null;
  this.ire = null;
  this.sde = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.sde !== undefined) {
      this.sde = args.sde;
    }
  }
};
Cassandra_system_add_keyspace_result.prototype = {};
Cassandra_system_add_keyspace_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException();
        this.sde.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_add_keyspace_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_add_keyspace_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0);
    output.writeString(this.success);
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.sde != null) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 2);
    this.sde.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_drop_keyspace_args = function(args) {
  this.keyspace = null;
  if (args) {
    if (args.keyspace !== undefined) {
      this.keyspace = args.keyspace;
    }
  }
};
Cassandra_system_drop_keyspace_args.prototype = {};
Cassandra_system_drop_keyspace_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.keyspace = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_drop_keyspace_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_drop_keyspace_args');
  if (this.keyspace != null) {
    output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1);
    output.writeString(this.keyspace);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_drop_keyspace_result = function(args) {
  this.success = null;
  this.ire = null;
  this.sde = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.sde !== undefined) {
      this.sde = args.sde;
    }
  }
};
Cassandra_system_drop_keyspace_result.prototype = {};
Cassandra_system_drop_keyspace_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException();
        this.sde.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_drop_keyspace_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_drop_keyspace_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0);
    output.writeString(this.success);
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.sde != null) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 2);
    this.sde.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_update_keyspace_args = function(args) {
  this.ks_def = null;
  if (args) {
    if (args.ks_def !== undefined) {
      this.ks_def = args.ks_def;
    }
  }
};
Cassandra_system_update_keyspace_args.prototype = {};
Cassandra_system_update_keyspace_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ks_def = new ttypes.KsDef();
        this.ks_def.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_update_keyspace_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_update_keyspace_args');
  if (this.ks_def != null) {
    output.writeFieldBegin('ks_def', Thrift.Type.STRUCT, 1);
    this.ks_def.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_update_keyspace_result = function(args) {
  this.success = null;
  this.ire = null;
  this.sde = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.sde !== undefined) {
      this.sde = args.sde;
    }
  }
};
Cassandra_system_update_keyspace_result.prototype = {};
Cassandra_system_update_keyspace_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException();
        this.sde.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_update_keyspace_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_update_keyspace_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0);
    output.writeString(this.success);
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.sde != null) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 2);
    this.sde.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_update_column_family_args = function(args) {
  this.cf_def = null;
  if (args) {
    if (args.cf_def !== undefined) {
      this.cf_def = args.cf_def;
    }
  }
};
Cassandra_system_update_column_family_args.prototype = {};
Cassandra_system_update_column_family_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.cf_def = new ttypes.CfDef();
        this.cf_def.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_update_column_family_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_update_column_family_args');
  if (this.cf_def != null) {
    output.writeFieldBegin('cf_def', Thrift.Type.STRUCT, 1);
    this.cf_def.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_update_column_family_result = function(args) {
  this.success = null;
  this.ire = null;
  this.sde = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.sde !== undefined) {
      this.sde = args.sde;
    }
  }
};
Cassandra_system_update_column_family_result.prototype = {};
Cassandra_system_update_column_family_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException();
        this.sde.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_update_column_family_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_update_column_family_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0);
    output.writeString(this.success);
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.sde != null) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 2);
    this.sde.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_execute_cql_query_args = function(args) {
  this.query = null;
  this.compression = null;
  if (args) {
    if (args.query !== undefined) {
      this.query = args.query;
    }
    if (args.compression !== undefined) {
      this.compression = args.compression;
    }
  }
};
Cassandra_execute_cql_query_args.prototype = {};
Cassandra_execute_cql_query_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.query = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.compression = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_execute_cql_query_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_execute_cql_query_args');
  if (this.query != null) {
    output.writeFieldBegin('query', Thrift.Type.STRING, 1);
    output.writeString(this.query);
    output.writeFieldEnd();
  }
  if (this.compression != null) {
    output.writeFieldBegin('compression', Thrift.Type.I32, 2);
    output.writeI32(this.compression);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_execute_cql_query_result = function(args) {
  this.success = null;
  this.ire = null;
  this.ue = null;
  this.te = null;
  this.sde = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
    if (args.sde !== undefined) {
      this.sde = args.sde;
    }
  }
};
Cassandra_execute_cql_query_result.prototype = {};
Cassandra_execute_cql_query_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRUCT) {
        this.success = new ttypes.CqlResult();
        this.success.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException();
        this.sde.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_execute_cql_query_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_execute_cql_query_result');
  if (this.success != null) {
    output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
    this.success.write(output);
    output.writeFieldEnd();
  }
  if (this.ire != null) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue != null) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te != null) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  if (this.sde != null) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 4);
    this.sde.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var CassandraClient = exports.Client = function(output, pClass) {
    this.output = output;
    this.pClass = pClass;
    this.seqid = 0;
    this._reqs = {};
};
CassandraClient.prototype = {};
CassandraClient.prototype.login = function(auth_request, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_login(auth_request);
};

CassandraClient.prototype.send_login = function(auth_request) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('login', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_login_args();
  args.auth_request = auth_request;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_login = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_login_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.authnx) {
    return callback(result.authnx);
  }
  if (null !== result.authzx) {
    return callback(result.authzx);
  }
  callback(null)
};
CassandraClient.prototype.set_keyspace = function(keyspace, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_set_keyspace(keyspace);
};

CassandraClient.prototype.send_set_keyspace = function(keyspace) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('set_keyspace', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_set_keyspace_args();
  args.keyspace = keyspace;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_set_keyspace = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_set_keyspace_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  callback(null)
};
CassandraClient.prototype.get = function(key, column_path, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_get(key, column_path, consistency_level);
};

CassandraClient.prototype.send_get = function(key, column_path, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('get', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_get_args();
  args.key = key;
  args.column_path = column_path;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_get = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_get_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.nfe) {
    return callback(result.nfe);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('get failed: unknown result');
};
CassandraClient.prototype.get_slice = function(key, column_parent, predicate, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_get_slice(key, column_parent, predicate, consistency_level);
};

CassandraClient.prototype.send_get_slice = function(key, column_parent, predicate, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('get_slice', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_get_slice_args();
  args.key = key;
  args.column_parent = column_parent;
  args.predicate = predicate;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_get_slice = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_get_slice_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('get_slice failed: unknown result');
};
CassandraClient.prototype.get_count = function(key, column_parent, predicate, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_get_count(key, column_parent, predicate, consistency_level);
};

CassandraClient.prototype.send_get_count = function(key, column_parent, predicate, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('get_count', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_get_count_args();
  args.key = key;
  args.column_parent = column_parent;
  args.predicate = predicate;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_get_count = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_get_count_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('get_count failed: unknown result');
};
CassandraClient.prototype.multiget_slice = function(keys, column_parent, predicate, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_multiget_slice(keys, column_parent, predicate, consistency_level);
};

CassandraClient.prototype.send_multiget_slice = function(keys, column_parent, predicate, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('multiget_slice', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_multiget_slice_args();
  args.keys = keys;
  args.column_parent = column_parent;
  args.predicate = predicate;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_multiget_slice = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_multiget_slice_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('multiget_slice failed: unknown result');
};
CassandraClient.prototype.multiget_count = function(keys, column_parent, predicate, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_multiget_count(keys, column_parent, predicate, consistency_level);
};

CassandraClient.prototype.send_multiget_count = function(keys, column_parent, predicate, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('multiget_count', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_multiget_count_args();
  args.keys = keys;
  args.column_parent = column_parent;
  args.predicate = predicate;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_multiget_count = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_multiget_count_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('multiget_count failed: unknown result');
};
CassandraClient.prototype.get_range_slices = function(column_parent, predicate, range, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_get_range_slices(column_parent, predicate, range, consistency_level);
};

CassandraClient.prototype.send_get_range_slices = function(column_parent, predicate, range, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('get_range_slices', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_get_range_slices_args();
  args.column_parent = column_parent;
  args.predicate = predicate;
  args.range = range;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_get_range_slices = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_get_range_slices_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('get_range_slices failed: unknown result');
};
CassandraClient.prototype.get_indexed_slices = function(column_parent, index_clause, column_predicate, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_get_indexed_slices(column_parent, index_clause, column_predicate, consistency_level);
};

CassandraClient.prototype.send_get_indexed_slices = function(column_parent, index_clause, column_predicate, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('get_indexed_slices', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_get_indexed_slices_args();
  args.column_parent = column_parent;
  args.index_clause = index_clause;
  args.column_predicate = column_predicate;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_get_indexed_slices = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_get_indexed_slices_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('get_indexed_slices failed: unknown result');
};
CassandraClient.prototype.insert = function(key, column_parent, column, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_insert(key, column_parent, column, consistency_level);
};

CassandraClient.prototype.send_insert = function(key, column_parent, column, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('insert', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_insert_args();
  args.key = key;
  args.column_parent = column_parent;
  args.column = column;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_insert = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_insert_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  callback(null)
};
CassandraClient.prototype.add = function(key, column_parent, column, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_add(key, column_parent, column, consistency_level);
};

CassandraClient.prototype.send_add = function(key, column_parent, column, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('add', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_add_args();
  args.key = key;
  args.column_parent = column_parent;
  args.column = column;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_add = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_add_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  callback(null)
};
CassandraClient.prototype.remove = function(key, column_path, timestamp, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_remove(key, column_path, timestamp, consistency_level);
};

CassandraClient.prototype.send_remove = function(key, column_path, timestamp, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('remove', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_remove_args();
  args.key = key;
  args.column_path = column_path;
  args.timestamp = timestamp;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_remove = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_remove_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  callback(null)
};
CassandraClient.prototype.remove_counter = function(key, path, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_remove_counter(key, path, consistency_level);
};

CassandraClient.prototype.send_remove_counter = function(key, path, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('remove_counter', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_remove_counter_args();
  args.key = key;
  args.path = path;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_remove_counter = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_remove_counter_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  callback(null)
};
CassandraClient.prototype.batch_mutate = function(mutation_map, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_batch_mutate(mutation_map, consistency_level);
};

CassandraClient.prototype.send_batch_mutate = function(mutation_map, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('batch_mutate', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_batch_mutate_args();
  args.mutation_map = mutation_map;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_batch_mutate = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_batch_mutate_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  callback(null)
};
CassandraClient.prototype.truncate = function(cfname, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_truncate(cfname);
};

CassandraClient.prototype.send_truncate = function(cfname) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('truncate', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_truncate_args();
  args.cfname = cfname;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_truncate = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_truncate_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  callback(null)
};
CassandraClient.prototype.describe_schema_versions = function(callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_describe_schema_versions();
};

CassandraClient.prototype.send_describe_schema_versions = function() {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_schema_versions', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_describe_schema_versions_args();
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_describe_schema_versions = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_describe_schema_versions_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('describe_schema_versions failed: unknown result');
};
CassandraClient.prototype.describe_keyspaces = function(callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_describe_keyspaces();
};

CassandraClient.prototype.send_describe_keyspaces = function() {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_keyspaces', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_describe_keyspaces_args();
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_describe_keyspaces = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_describe_keyspaces_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('describe_keyspaces failed: unknown result');
};
CassandraClient.prototype.describe_cluster_name = function(callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_describe_cluster_name();
};

CassandraClient.prototype.send_describe_cluster_name = function() {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_cluster_name', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_describe_cluster_name_args();
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_describe_cluster_name = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_describe_cluster_name_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('describe_cluster_name failed: unknown result');
};
CassandraClient.prototype.describe_version = function(callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_describe_version();
};

CassandraClient.prototype.send_describe_version = function() {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_version', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_describe_version_args();
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_describe_version = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_describe_version_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('describe_version failed: unknown result');
};
CassandraClient.prototype.describe_ring = function(keyspace, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_describe_ring(keyspace);
};

CassandraClient.prototype.send_describe_ring = function(keyspace) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_ring', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_describe_ring_args();
  args.keyspace = keyspace;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_describe_ring = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_describe_ring_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('describe_ring failed: unknown result');
};
CassandraClient.prototype.describe_partitioner = function(callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_describe_partitioner();
};

CassandraClient.prototype.send_describe_partitioner = function() {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_partitioner', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_describe_partitioner_args();
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_describe_partitioner = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_describe_partitioner_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('describe_partitioner failed: unknown result');
};
CassandraClient.prototype.describe_snitch = function(callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_describe_snitch();
};

CassandraClient.prototype.send_describe_snitch = function() {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_snitch', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_describe_snitch_args();
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_describe_snitch = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_describe_snitch_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('describe_snitch failed: unknown result');
};
CassandraClient.prototype.describe_keyspace = function(keyspace, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_describe_keyspace(keyspace);
};

CassandraClient.prototype.send_describe_keyspace = function(keyspace) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_keyspace', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_describe_keyspace_args();
  args.keyspace = keyspace;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_describe_keyspace = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_describe_keyspace_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.nfe) {
    return callback(result.nfe);
  }
  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('describe_keyspace failed: unknown result');
};
CassandraClient.prototype.describe_splits = function(cfName, start_token, end_token, keys_per_split, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_describe_splits(cfName, start_token, end_token, keys_per_split);
};

CassandraClient.prototype.send_describe_splits = function(cfName, start_token, end_token, keys_per_split) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_splits', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_describe_splits_args();
  args.cfName = cfName;
  args.start_token = start_token;
  args.end_token = end_token;
  args.keys_per_split = keys_per_split;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_describe_splits = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_describe_splits_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('describe_splits failed: unknown result');
};
CassandraClient.prototype.system_add_column_family = function(cf_def, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_system_add_column_family(cf_def);
};

CassandraClient.prototype.send_system_add_column_family = function(cf_def) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_add_column_family', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_system_add_column_family_args();
  args.cf_def = cf_def;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_system_add_column_family = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_system_add_column_family_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.sde) {
    return callback(result.sde);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('system_add_column_family failed: unknown result');
};
CassandraClient.prototype.system_drop_column_family = function(column_family, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_system_drop_column_family(column_family);
};

CassandraClient.prototype.send_system_drop_column_family = function(column_family) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_drop_column_family', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_system_drop_column_family_args();
  args.column_family = column_family;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_system_drop_column_family = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_system_drop_column_family_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.sde) {
    return callback(result.sde);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('system_drop_column_family failed: unknown result');
};
CassandraClient.prototype.system_add_keyspace = function(ks_def, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_system_add_keyspace(ks_def);
};

CassandraClient.prototype.send_system_add_keyspace = function(ks_def) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_add_keyspace', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_system_add_keyspace_args();
  args.ks_def = ks_def;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_system_add_keyspace = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_system_add_keyspace_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.sde) {
    return callback(result.sde);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('system_add_keyspace failed: unknown result');
};
CassandraClient.prototype.system_drop_keyspace = function(keyspace, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_system_drop_keyspace(keyspace);
};

CassandraClient.prototype.send_system_drop_keyspace = function(keyspace) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_drop_keyspace', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_system_drop_keyspace_args();
  args.keyspace = keyspace;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_system_drop_keyspace = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_system_drop_keyspace_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.sde) {
    return callback(result.sde);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('system_drop_keyspace failed: unknown result');
};
CassandraClient.prototype.system_update_keyspace = function(ks_def, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_system_update_keyspace(ks_def);
};

CassandraClient.prototype.send_system_update_keyspace = function(ks_def) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_update_keyspace', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_system_update_keyspace_args();
  args.ks_def = ks_def;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_system_update_keyspace = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_system_update_keyspace_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.sde) {
    return callback(result.sde);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('system_update_keyspace failed: unknown result');
};
CassandraClient.prototype.system_update_column_family = function(cf_def, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_system_update_column_family(cf_def);
};

CassandraClient.prototype.send_system_update_column_family = function(cf_def) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_update_column_family', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_system_update_column_family_args();
  args.cf_def = cf_def;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_system_update_column_family = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_system_update_column_family_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.sde) {
    return callback(result.sde);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('system_update_column_family failed: unknown result');
};
CassandraClient.prototype.execute_cql_query = function(query, compression, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_execute_cql_query(query, compression);
};

CassandraClient.prototype.send_execute_cql_query = function(query, compression) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('execute_cql_query', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_execute_cql_query_args();
  args.query = query;
  args.compression = compression;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_execute_cql_query = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_execute_cql_query_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  if (null !== result.sde) {
    return callback(result.sde);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('execute_cql_query failed: unknown result');
};
var CassandraProcessor = exports.Processor = function(handler) {
  this._handler = handler
}
CassandraProcessor.prototype.process = function(input, output) {
  var r = input.readMessageBegin();
  if (this['process_' + r.fname]) {
    return this['process_' + r.fname].call(this, r.rseqid, input, output);
  } else {
    input.skip(Thrift.Type.STRUCT);
    input.readMessageEnd();
    var x = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN_METHOD, 'Unknown function ' + r.fname);
    output.writeMessageBegin(r.fname, Thrift.MessageType.Exception, r.rseqid);
    x.write(output);
    output.writeMessageEnd();
    output.flush();
  }
}

CassandraProcessor.prototype.process_login = function(seqid, input, output) {
  var args = new Cassandra_login_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_login_result();
  this._handler.login(args.auth_request, function (success) {
    result.success = success;
    output.writeMessageBegin("login", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_set_keyspace = function(seqid, input, output) {
  var args = new Cassandra_set_keyspace_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_set_keyspace_result();
  this._handler.set_keyspace(args.keyspace, function (success) {
    result.success = success;
    output.writeMessageBegin("set_keyspace", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_get = function(seqid, input, output) {
  var args = new Cassandra_get_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_get_result();
  this._handler.get(args.key, args.column_path, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("get", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_get_slice = function(seqid, input, output) {
  var args = new Cassandra_get_slice_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_get_slice_result();
  this._handler.get_slice(args.key, args.column_parent, args.predicate, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("get_slice", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_get_count = function(seqid, input, output) {
  var args = new Cassandra_get_count_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_get_count_result();
  this._handler.get_count(args.key, args.column_parent, args.predicate, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("get_count", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_multiget_slice = function(seqid, input, output) {
  var args = new Cassandra_multiget_slice_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_multiget_slice_result();
  this._handler.multiget_slice(args.keys, args.column_parent, args.predicate, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("multiget_slice", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_multiget_count = function(seqid, input, output) {
  var args = new Cassandra_multiget_count_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_multiget_count_result();
  this._handler.multiget_count(args.keys, args.column_parent, args.predicate, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("multiget_count", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_get_range_slices = function(seqid, input, output) {
  var args = new Cassandra_get_range_slices_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_get_range_slices_result();
  this._handler.get_range_slices(args.column_parent, args.predicate, args.range, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("get_range_slices", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_get_indexed_slices = function(seqid, input, output) {
  var args = new Cassandra_get_indexed_slices_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_get_indexed_slices_result();
  this._handler.get_indexed_slices(args.column_parent, args.index_clause, args.column_predicate, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("get_indexed_slices", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_insert = function(seqid, input, output) {
  var args = new Cassandra_insert_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_insert_result();
  this._handler.insert(args.key, args.column_parent, args.column, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("insert", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_add = function(seqid, input, output) {
  var args = new Cassandra_add_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_add_result();
  this._handler.add(args.key, args.column_parent, args.column, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("add", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_remove = function(seqid, input, output) {
  var args = new Cassandra_remove_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_remove_result();
  this._handler.remove(args.key, args.column_path, args.timestamp, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("remove", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_remove_counter = function(seqid, input, output) {
  var args = new Cassandra_remove_counter_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_remove_counter_result();
  this._handler.remove_counter(args.key, args.path, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("remove_counter", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_batch_mutate = function(seqid, input, output) {
  var args = new Cassandra_batch_mutate_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_batch_mutate_result();
  this._handler.batch_mutate(args.mutation_map, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("batch_mutate", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_truncate = function(seqid, input, output) {
  var args = new Cassandra_truncate_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_truncate_result();
  this._handler.truncate(args.cfname, function (success) {
    result.success = success;
    output.writeMessageBegin("truncate", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_describe_schema_versions = function(seqid, input, output) {
  var args = new Cassandra_describe_schema_versions_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_describe_schema_versions_result();
  this._handler.describe_schema_versions(function (success) {
    result.success = success;
    output.writeMessageBegin("describe_schema_versions", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_describe_keyspaces = function(seqid, input, output) {
  var args = new Cassandra_describe_keyspaces_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_describe_keyspaces_result();
  this._handler.describe_keyspaces(function (success) {
    result.success = success;
    output.writeMessageBegin("describe_keyspaces", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_describe_cluster_name = function(seqid, input, output) {
  var args = new Cassandra_describe_cluster_name_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_describe_cluster_name_result();
  this._handler.describe_cluster_name(function (success) {
    result.success = success;
    output.writeMessageBegin("describe_cluster_name", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_describe_version = function(seqid, input, output) {
  var args = new Cassandra_describe_version_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_describe_version_result();
  this._handler.describe_version(function (success) {
    result.success = success;
    output.writeMessageBegin("describe_version", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_describe_ring = function(seqid, input, output) {
  var args = new Cassandra_describe_ring_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_describe_ring_result();
  this._handler.describe_ring(args.keyspace, function (success) {
    result.success = success;
    output.writeMessageBegin("describe_ring", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_describe_partitioner = function(seqid, input, output) {
  var args = new Cassandra_describe_partitioner_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_describe_partitioner_result();
  this._handler.describe_partitioner(function (success) {
    result.success = success;
    output.writeMessageBegin("describe_partitioner", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_describe_snitch = function(seqid, input, output) {
  var args = new Cassandra_describe_snitch_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_describe_snitch_result();
  this._handler.describe_snitch(function (success) {
    result.success = success;
    output.writeMessageBegin("describe_snitch", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_describe_keyspace = function(seqid, input, output) {
  var args = new Cassandra_describe_keyspace_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_describe_keyspace_result();
  this._handler.describe_keyspace(args.keyspace, function (success) {
    result.success = success;
    output.writeMessageBegin("describe_keyspace", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_describe_splits = function(seqid, input, output) {
  var args = new Cassandra_describe_splits_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_describe_splits_result();
  this._handler.describe_splits(args.cfName, args.start_token, args.end_token, args.keys_per_split, function (success) {
    result.success = success;
    output.writeMessageBegin("describe_splits", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_system_add_column_family = function(seqid, input, output) {
  var args = new Cassandra_system_add_column_family_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_system_add_column_family_result();
  this._handler.system_add_column_family(args.cf_def, function (success) {
    result.success = success;
    output.writeMessageBegin("system_add_column_family", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_system_drop_column_family = function(seqid, input, output) {
  var args = new Cassandra_system_drop_column_family_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_system_drop_column_family_result();
  this._handler.system_drop_column_family(args.column_family, function (success) {
    result.success = success;
    output.writeMessageBegin("system_drop_column_family", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_system_add_keyspace = function(seqid, input, output) {
  var args = new Cassandra_system_add_keyspace_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_system_add_keyspace_result();
  this._handler.system_add_keyspace(args.ks_def, function (success) {
    result.success = success;
    output.writeMessageBegin("system_add_keyspace", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_system_drop_keyspace = function(seqid, input, output) {
  var args = new Cassandra_system_drop_keyspace_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_system_drop_keyspace_result();
  this._handler.system_drop_keyspace(args.keyspace, function (success) {
    result.success = success;
    output.writeMessageBegin("system_drop_keyspace", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_system_update_keyspace = function(seqid, input, output) {
  var args = new Cassandra_system_update_keyspace_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_system_update_keyspace_result();
  this._handler.system_update_keyspace(args.ks_def, function (success) {
    result.success = success;
    output.writeMessageBegin("system_update_keyspace", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_system_update_column_family = function(seqid, input, output) {
  var args = new Cassandra_system_update_column_family_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_system_update_column_family_result();
  this._handler.system_update_column_family(args.cf_def, function (success) {
    result.success = success;
    output.writeMessageBegin("system_update_column_family", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_execute_cql_query = function(seqid, input, output) {
  var args = new Cassandra_execute_cql_query_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_execute_cql_query_result();
  this._handler.execute_cql_query(args.query, args.compression, function (success) {
    result.success = success;
    output.writeMessageBegin("execute_cql_query", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

